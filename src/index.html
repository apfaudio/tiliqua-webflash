<!DOCTYPE html>
<html>
<head>
    <title>Tiliqua Flash Tool</title>
    <meta charset="UTF-8">
    <script src="coi-serviceworker.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h1 {
            margin-bottom: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
        button, input, select {
            font-family: monospace;
            padding: 8px 12px;
            margin-right: 10px;
            font-size: 14px;
        }
        #terminal {
            margin-top: 20px;
        }
        #status {
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <h1>Tiliqua Flash Tool</h1>

    <div class="controls">
        <button id="connect">Connect to Tiliqua</button>
        <span id="status">Not connected</span>
    </div>

    <div class="controls">
        <input type="file" id="archive" accept=".tar.gz" disabled>
        <select id="slot" disabled>
            <option value="null">Bootloader</option>
            <option value="0">Slot 0</option>
            <option value="1">Slot 1</option>
            <option value="2">Slot 2</option>
            <option value="3">Slot 3</option>
            <option value="4">Slot 4</option>
            <option value="5">Slot 5</option>
            <option value="6">Slot 6</option>
            <option value="7">Slot 7</option>
        </select>
        <button id="flash" disabled>Flash</button>
    </div>

    <div id="terminal"></div>

    <script type="module">
import { runOpenFPGALoader, Exit } from 'https://cdn.jsdelivr.net/npm/@yowasp/openfpgaloader/gen/bundle.js';

// Global state
let pyodide = null;
let tiliquaHwVersion = null;
let selectedFile = null;
let term = null;

// Initialize xterm.js
function initTerminal() {
    term = new Terminal({
        theme: {
            background: '#1e1e1e',
            foreground: '#d4d4d4'
        }
    });
    term.open(document.getElementById('terminal'));
    term.writeln('Terminal initialized. Waiting for Pyodide...');
}

// Log to terminal
function log(message, style = '') {
    if (term) {
        term.writeln(style + message + '\x1b[0m');
    }
}

// Initialize Pyodide
async function initPyodide() {
    log('Loading Pyodide...');
    pyodide = await loadPyodide();

    // Install required packages
    log('Installing Python packages...');
    await pyodide.loadPackage('micropip');
    const micropip = pyodide.pyimport('micropip');
    await micropip.install(['dataclasses-json', 'colorama']);

    // Mount the current directory so Python can import modules
    log('Setting up Python module paths...');

    // Create empty __init__.py files for module structure
    const emptyInitFiles = [
        'tiliqua/__init__.py',
        'tiliqua/build/__init__.py',
        'tiliqua/flash/__init__.py',
        'rs/__init__.py',
        'rs/manifest/__init__.py',
        'rs/manifest/src/__init__.py',
    ];

    for (const file of emptyInitFiles) {
        const dir = file.substring(0, file.lastIndexOf('/'));
        if (dir) {
            const parts = dir.split('/');
            let currentPath = '';
            for (const part of parts) {
                currentPath = currentPath ? `${currentPath}/${part}` : part;
                try {
                    pyodide.FS.mkdir(currentPath);
                } catch (e) {
                    // Directory might already exist
                }
            }
        }
        pyodide.FS.writeFile(file, '');
        log(`Created ${file}`);
    }

    // Fetch and write all Python files to Pyodide's filesystem
    const pythonFiles = [
        'tiliqua/build/types.py',
        'tiliqua/flash/archive_loader.py',
        'tiliqua/flash/spiflash_layout.py',
        'tiliqua/flash/openfpgaloader.py',
        'rs/manifest/src/lib.py',
        'rs/manifest/src/lib.rs',
    ];

    for (const file of pythonFiles) {
        try {
            log(`Fetching ${file}...`);
            const response = await fetch(file);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const content = await response.text();
            log(`Got ${content.length} bytes, writing to FS...`);

            // Create directory structure
            const dir = file.substring(0, file.lastIndexOf('/'));
            if (dir) {
                const parts = dir.split('/');
                let currentPath = '';
                for (const part of parts) {
                    currentPath = currentPath ? `${currentPath}/${part}` : part;
                    try {
                        pyodide.FS.mkdir(currentPath);
                    } catch (e) {
                        // Directory might already exist, that's okay
                    }
                }
            }

            // Write file (even if empty)
            pyodide.FS.writeFile(file, content || '');
            log(`\x1b[32mLoaded ${file}\x1b[0m`);
        } catch (e) {
            log(`\x1b[31mError loading ${file}: ${e}\x1b[0m`);
            console.error(`Full error for ${file}:`, e);
            throw e;  // Stop initialization if we can't load required files
        }
    }

    log('\x1b[32mPyodide initialized successfully\x1b[0m');
    document.getElementById('connect').disabled = false;
}

// Scan for Tiliqua device
async function scanForTiliqua() {
    try {
        log('Scanning for Tiliqua...');

        // Try to get previously connected devices first
        const devices = await navigator.usb.getDevices();
        let tiliquaDevice = null;

        for (const device of devices) {
            if (device.productName &&
                (device.productName.toLowerCase().includes('apfbug') ||
                 device.productName.toLowerCase().includes('apf.audio'))) {
                tiliquaDevice = device;
                break;
            }
        }

        // If not found, request device from user
        if (!tiliquaDevice) {
            tiliquaDevice = await navigator.usb.requestDevice({
                filters: []
            });
        }

        if (!tiliquaDevice) {
            throw new Error("No device selected");
        }

        const productName = tiliquaDevice.productName || "";
        if (!productName.toLowerCase().includes('apfbug') &&
            !productName.toLowerCase().includes('apf.audio')) {
            throw new Error("Selected device is not a Tiliqua debugger");
        }

        // Extract hardware version from product name (e.g. "Tiliqua R4")
        const hwVersionMatch = productName.match(/R(\d+)/);
        if (hwVersionMatch) {
            tiliquaHwVersion = parseInt(hwVersionMatch[1]);
            log(`\x1b[32mFound Tiliqua! (hw_rev=R${tiliquaHwVersion}, serial=${tiliquaDevice.serialNumber})\x1b[0m`);

            const statusEl = document.getElementById('status');
            statusEl.textContent = `Connected: ${productName} (hw_rev=R${tiliquaHwVersion})`;
            statusEl.style.color = '#4CAF50';

            document.getElementById('archive').disabled = false;

            return tiliquaHwVersion;
        } else {
            throw new Error("Found tiliqua-like device, product code is malformed (update RP2040?)");
        }

    } catch (error) {
        let errorMsg = error.message || "Unknown error";
        let additionalInfo = "Check device is on, plugged in ('dbg' port), permissions correct, RP2040 firmware up to date.";

        if (error.message && error.message.includes("navigator.usb is undefined")) {
            errorMsg = "WebUSB is not supported in this browser";
            additionalInfo = "Use Chrome, Edge, or another Chromium-based browser. Firefox does not support WebUSB.";
        } else if (!navigator.usb) {
            errorMsg = "WebUSB is not supported in this browser";
            additionalInfo = "Use Chrome, Edge, or another Chromium-based browser.";
        }

        log(`\x1b[31mError: ${errorMsg}\x1b[0m`);
        log(`\x1b[33m${additionalInfo}\x1b[0m`);

        const statusEl = document.getElementById('status');
        statusEl.textContent = `Error: ${errorMsg}`;
        statusEl.style.color = '#ff6b6b';
        return null;
    }
}

// Handle file selection
async function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        selectedFile = await file.arrayBuffer();
        log(`\x1b[36mLoaded archive: ${file.name} (${selectedFile.byteLength} bytes)\x1b[0m`);
        document.getElementById('slot').disabled = false;
        document.getElementById('flash').disabled = false;
    }
}

// Handle flash operation
async function handleFlash() {
    if (!selectedFile || tiliquaHwVersion === null) {
        log('\x1b[31mError: No file selected or device not connected\x1b[0m');
        return;
    }

    const slotValue = document.getElementById('slot').value;
    const slot = slotValue === 'null' ? null : parseInt(slotValue);

    log('');
    log('\x1b[1m=== Starting Flash Operation ===\x1b[0m');
    log(`Slot: ${slot === null ? 'Bootloader' : slot}`);
    log(`Hardware: R${tiliquaHwVersion}`);

    try {
        // Disable controls during flashing
        document.getElementById('flash').disabled = true;
        document.getElementById('slot').disabled = true;
        document.getElementById('archive').disabled = true;

        // Call Python to process archive
        log('\x1b[36mProcessing archive...\x1b[0m');

        pyodide.globals.set('archive_bytes', new Uint8Array(selectedFile));
        pyodide.globals.set('slot_value', slot);
        pyodide.globals.set('hw_rev_value', tiliquaHwVersion);

        const result = await pyodide.runPythonAsync(`
import io
import tarfile
import json
from tiliqua.build.types import BitstreamManifest, RegionType
from tiliqua.flash.spiflash_layout import compute_concrete_regions_to_flash

# Extract archive
archive_buffer = io.BytesIO(bytes(archive_bytes))
files = {}

with tarfile.open(fileobj=archive_buffer, mode='r:gz') as tar:
    for member in tar.getmembers():
        if member.isfile():
            f = tar.extractfile(member)
            files[member.name] = f.read()

# Parse manifest
manifest_json = files.get('manifest.json')
if not manifest_json:
    raise ValueError("No manifest.json found in archive")

manifest_dict = json.loads(manifest_json.decode('utf-8'))
manifest = BitstreamManifest.from_dict(manifest_dict)

# Validate hardware
if manifest.hw_rev != hw_rev_value:
    raise ValueError(f"Hardware mismatch: attached Tiliqua (hw=r{hw_rev_value}) does not match archive (hw=r{manifest.hw_rev})")

# Check if bootloader or user bitstream
is_bootloader = any(r.region_type == RegionType.XipFirmware for r in manifest.regions)
if is_bootloader and slot_value is not None:
    raise ValueError("Bootloader bitstream must be flashed to bootloader slot (select 'Bootloader' option)")
elif not is_bootloader and slot_value is None:
    raise ValueError("User bitstream requires a slot selection (0-7)")

# Compute concrete regions
concrete_manifest, regions_to_flash = compute_concrete_regions_to_flash(manifest, slot_value)

# Update manifest in files
files['manifest.json'] = json.dumps(concrete_manifest.to_dict()).encode('utf-8')

# Generate operations
operations = []
for i, region in enumerate(sorted(regions_to_flash)):
    if region.memory_region.region_type == RegionType.OptionStorage:
        continue  # Skip option storage

    filename = region.memory_region.filename
    if filename not in files:
        raise ValueError(f"File {filename} referenced in manifest but not found in archive")

    data = files[filename]

    operations.append({
        'filename': filename,
        'data': list(data),  # Convert bytes to list for JSON
        'offset': region.addr,
        'file_type': 'raw',
        'skip_reset': i < len(regions_to_flash) - 1
    })

result = {
    'operations': operations,
    'manifest': concrete_manifest.to_dict(),
    'is_bootloader': is_bootloader
}

json.dumps(result)
        `);

        const processedData = JSON.parse(result);

        log(`\x1b[32mArchive processed successfully\x1b[0m`);
        log(`Manifest: ${processedData.manifest.name}`);
        log(`Type: ${processedData.is_bootloader ? 'Bootloader (XiP)' : 'User bitstream'}`);
        log('');

        // Show operations
        log('\x1b[1mOperations to execute:\x1b[0m');
        for (const op of processedData.operations) {
            const args = [
                '-c', 'dirtyJtag',
                '-f',
                '-o', `0x${op.offset.toString(16)}`,
                '--file-type', op.file_type
            ];
            if (op.skip_reset) {
                args.push('--skip-reset');
            }
            log(`  \$ openFPGALoader ${args.join(' ')} ${op.filename}`);
        }
        log('');

        // Execute operations
        log('\x1b[1mExecuting flash commands...\x1b[0m');
        for (const op of processedData.operations) {
            const data = new Uint8Array(op.data);

            const args = [
                '-c', 'dirtyJtag',
                '-f',
                '-o', `0x${op.offset.toString(16)}`,
                '--file-type', op.file_type
            ];

            if (op.skip_reset) {
                args.push('--skip-reset');
            }

            args.push('data');

            const filesIn = { 'data': data };

            try {
                await runOpenFPGALoader(args, filesIn, {
                    stdout: (data) => {
                        if (data) {
                            const text = new TextDecoder().decode(data);
                            log(text.trim());
                        }
                    },
                    stderr: (data) => {
                        if (data) {
                            const text = new TextDecoder().decode(data);
                            log(`\x1b[33m${text.trim()}\x1b[0m`);
                        }
                    }
                });
            } catch (error) {
                if (error instanceof Exit) {
                    throw new Error(`Command failed with exit code ${error.code}`);
                }
                throw error;
            }
        }

        log('');
        log('\x1b[32m\x1b[1mFlashing completed successfully!\x1b[0m');

    } catch (error) {
        log('');
        log(`\x1b[31m\x1b[1mFlash failed: ${error.message}\x1b[0m`);
    } finally {
        // Re-enable controls
        document.getElementById('flash').disabled = false;
        document.getElementById('slot').disabled = false;
        document.getElementById('archive').disabled = false;
    }
}

// Setup event listeners
document.addEventListener('DOMContentLoaded', () => {
    initTerminal();
    initPyodide();

    document.getElementById('connect').addEventListener('click', scanForTiliqua);
    document.getElementById('archive').addEventListener('change', handleFileSelect);
    document.getElementById('flash').addEventListener('click', handleFlash);
});
    </script>
</body>
</html>
